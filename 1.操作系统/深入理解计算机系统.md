# 第一部分 程序的结构和执行

## 1 .c件编译成为可执行文件

1. 预处理器：替换以#号开头的宏定义，生成.i文件（文本）
2. 编译器：将文本编译为汇编程序，生成.s文件（文本）
3. 汇编器：将汇编程序编译为可重定位目标程序，生成.o文件（二进制程序）
4. 链接器：将可重定位目标程序链接成可执行目标程序（二进制）

比如说执行printf函数，先对#include<stdio.h>进行文本替换，然后生成汇编语言，在生成可重定位的目标程序，然后在以某种方式合并，这个目标文件和预编译好的printf.o的目标文件。

## 2.控制器和适配器的区别

控制器：IO设备本身的电路板。

适配器：插在主板插槽上的卡。

功能都是在IO总线和IO设备中传递信息。

## 3. 系统硬件的组成

1. 总线：负责在各个部件间传递信息。

2. IO设备：系统与外界的联系通道。

3. 主存：处理器执行程序时，用来存放程序和程序所需要的设备。

   在64位操作系统中：short 是2个字节，int、float是4个字节，long、double是8个字节。

   int32_t 是4个字节，int64_是8个字节

4. 处理器：存储在主存中的指令的引擎。

   处理器的核心是一个大小为一个字的存储设备（寄存器），称为程序计数器，在任何时刻，PC都指向某条机器语言指令。

## 4. 高速缓存存储器

高速缓存存储器可以暂存近期可能会用到的信息，其访问速度比普通存储器的速度快得多。

比如说：处理器处理程序从主存中复制到处理器中比从普通磁盘中复制到处理器中快得多，从主存中复制数据，这样可以跟得上处理器的速度。

还有一般的CPU会有L1、L2高速缓存，这是用一种叫做静态随机访问存储器的硬件技术实现的。访问L1的速度和寄存器的几乎一样，访问L2的比主存的快5到10倍。还有一些较新的系统甚至有三级高速缓存。使用高速缓存的原理是局部性原理，局部性原理包括时间局部性原理和空间局部性原理。时间局部性原理就是系统访问过的一段信息，在不久的将来可能还会去访问；空间局部性原理是系统访问一段信息，可能会访问它周围的信息。

## 5. 存储器的层次结构

- 寄存器
- L1高速缓存：分为两部分，一个存放最近取到的指令，另一个存放数据
- L2高速缓存
- L3高速缓存
- 主存
- 本地磁盘
- 分布式系统、web服务器

思想：上一层的存储器作为低一层存储器的高速缓存。

## 6. 操作系统

功能：1. 防止硬件被失控的应用程序滥用；2. 管理硬件设备。

通过进程、虚拟内存、文件来实现上述系统。

## 7. 上下文切换

操作系统决定要把处理器控制权从当前进程交给另外一个进程，就要进行上下文切换，保存当前进程的上下文，恢复新进程的上下文。

## 8. 虚拟内存

虚拟内存就是位每个进程提供一个假象，每个进程看到的内存空间都是一致的，称为虚拟地址空间。

## 9. 每个进程的存储空间格式

从低地址到高地址依次是：程序代码和数据（一开始就被制定了大小）、堆（malloc、free控制堆的大小）、共享库（存放C标准库、数学库等）、栈（实现函数调用，动态扩展和收缩）、内核虚拟内存（为内核保留）。

## 10.大端模式和小端模式

大端模式：高字节在低地址。大端反常。

小端模式：高字节在高地址。小端正常。

0x1234。12就是高字节。

## 11.补码编码

最高位是负权值，其他的是正权值。

## 12.switch语句

switch语句可以根据一个整数索引值进行多重分支，通过使用跳转表的数据结构使得实现更加高效。

跳转表是一个数组，表项i是一个代码段的地址，这个代码短实现当开关索引值等于i时采取的动作。

if-else 执行开关语句的速度与开关情况的数量有关。

## 13. 运行时栈

栈是一种先入后出的数据结构，加入过程P调用过程Q，P之前的过程就被暂时挂起。当Q运行的时候，就为局部变量分配新的存储空间，当Q返回时，就释放所分配的局部变量。可以用pushq和popq指令将数据存入栈中，或是从栈中取出。将栈指针减小一个适当的量可以为没有分配初始值的数据分配空间。同样，增加栈指针可以释放空间。

## 14. 转移控制

将控制从函数P（调用者）转移到函数Q（被调用者）中，只需要将程序计数器设置为Q的代码的起始位置，但是当Q返回时，处理器必须记录好他需要继续执行过程P的执行位置。

## 15. 数据对齐

计算机要求某种类型的对象的地址必须是某个值（通常是2、4、8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的设计。不足的话就补齐。C语言中一般是对char、short之后进行补齐操作。

## 16. gcc编译选项

-E 生成预处理文件

-S 生成汇编文件

-c 生成可重定位目标文件

-o 生成可执行目标文件

-On 代码优化等级

-g gdb调试

-Wall 显示代码中所有的warning行为

-w 禁止显示代码中的warning行为

-Werror 将代码中的warning行为视为error行为

-D 设置预定义宏

-l 链接指定函数库

-std=c++11 指定编译代码的C++标准为C++11

## 16. gdb的使用

### 编译

```shell
gdb -g  -O0 main.c -0 main
```

### 启动

```shell
gdb main
或者
sudo gdb
attach pid #调试进程的信息
detach #退出调试
或者
gdb -p pid #和attach一样
detach #退出
```

### 运行程序

```shell
run、r
```

### set args

```shell
set args
如启动REDIS的哨兵服务器时，需要设置哨兵模式下的配置文件路径
set args /home/szza/redis-6.0.5/redis-6.0.5/sentinel.conf --sentinel #设置输入参数
r #运行
```

### 退出gdb

```shell
q、quit
```

### 断点

b、break

```shell
break #break后面没有任何参数，那么就是在当前栈帧的下一指令处加上断点
break line #在当前运行程序行处加断点，如果想在其他文件下加上端点 break filename:line
break function #在当前运行程序的function处加上断点
	c++会发生重载，甚至不同类存在同名函数，那么可以更加具体的设置：
	break filename:function #在filename文件夹下的function处加上断点
	break filename:function(ArgsType) #在filename文件夹的function（args）处加上断点
	break class:funtion #在类class的function处加上断点，函数可以加上具体参数
	
```

### break...if cond

如果只想满足某个条件时，才触发断点使用这个命令

如

```shell
break 7 if con>3
```

### info b

查看断点信息

### disable、enable、delete

```shell
disable n1 n2 n3 #临时关闭百年好位n1、n2、n3的的断点

enable n1 n2 n3 #开启被disable指令关闭的断点n1、n2、n3

delete n1 n2 n3 #直接删除断点n1、n2、n3
如果diable、enable、delete后面没有跟参数，那么就是关闭、开启、删除所有断点
```

### 执行流程

next

step

- continue，简写c

  恢复被break指令终端的程序，使其继续向下执行

- step，简写s

  step [count] 指令，逐步执行count个步骤，而不是count个语句、函数。当不屑count的时候，默认就执行一步

  step指令，用于配合break指令一起使用，当在某个函数起始处触发断点，想要进入该函数体，则可以使用step指令。而step count则是依次行执行count步，避免繁琐的中间行为，比如避免C++的构造函数

- next [count]，简写n

  next指令，是逐函数执行，即当停在断点触发的函数处：step是逐步执行，下一步进入函数体中；next指令会直接执行完整个函数，然后进入下一行。

### set step-mode

如果某个函数、语句没有包含debug信息，gdb默认就会跳过这个函数、语句。但是可以通过设置step-mode选项是否跳过。

```shell
set step-mode on #不跳过没有调试信息的函数、语句
set step-mode off #默认行为，跳过
#可以通过show step-mode来查看
```

### finish，简写fin

用于将当前函数剩下的部分执行完毕，并且显示输出结果

可以控制finish显示和不显示返回结果：

``` shell
set print finish [on|off] #控制finish返回结果是否显示
show print finfish #输出finish的返回结果是否显示
```

### return

finish是把剩余的执行完，return是直接在函数的当前位置返回，不管执行到什么位置

### until，简写u

可以用于直接跳出循环体

until指令，不加参数，没有遇到循环体时功能类似于next，遇到了可以直接跳出循环体

until location，和break location格式一样，可以直接运行到指定行数

### 显示

print：手动输出

display：自动显示

- print [[options] --] expr：其中expr可以是表达式、变量。其中输出的变量要么是全局白能量、staic变量、局部变量。

- print [[options] --] /f expr

  /f是expr的输出格式

  x 按十六进制格式显示

  a 按十六进制格式显示变量值

  d 十进制

  u 十六进制格式显示无符号整数

  o 八进制

  t 二进制

  c 按字符格式显示变量

  f 按浮点数格式显示变量

  s 按字符串显示

  z 与x一样，但是前导0被打印出来

  r 'r'是“raw”的缩写，按照python的Pretty-printer风格进行打印

  $pc代表当前指令的地址

- display /f expr与print /f expr格式基本一致，但是运行每一条语句都会显示expr的值

- display /f addr

  当自动显示的是地址显示，可以使用/i格式描述符，查看地址addr的汇编代码

### 栈帧

backtrace指令，简写bt，可以在break指令设置的断点触发时，查看程序是怎么执行到此断点处的，追踪下栈帧信息。

可以查看到调用链

### frame N

frame指令，简写f，frame N表示跳转到编号为N栈帧中，不加参数的frame指令，可以显示当前栈帧的基本信息。

想看某一个函数，需要进入调用这个函数的栈帧。

### info frame

简写info f，会显示当前栈帧的详细信息，比如：当前调用函数的地址，被调用函数的地址，源码语言、函数参数地址及值、局部变量的地址等等。

### info args

info args指令，可以获取当前栈帧的参数名及其值

### info local

打印出当前函数中的所有局部变量及其值。

### 补充

- 执行shell指令，在指令前面加shell即可，如shell clear
- 空行：在gdb下，直接回车，即输入一个空行，相当于重复执行上一条指令。



## 17.链接

将各种代码和数据片段收集并组合称为一个单一文件的过程，这个文件可以被加载到内存并执行。可以发生在编译（源代码翻译为机器代码）时，也可以发生于加载（程序被加载器加载到内存并执行）时，甚至可以发生在运行（由应用程序来执行）时。链接是由链接器程序自动执行的。

## 18. 目标文件分类

可重定位目标文件（在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件）、可执行目标文件（可以被直接复制到内存并执行的文件）、共享目标文件（在加载或者运行时动态加载进内存并链接）。

## 19. .data段和.bss段

.data段存储已初始化的全局和静态变量；.bss段存储未初始化的全局和静态变量，以及所有被初始化为0的全局或静态变量。

## 20. 静态变量

在同一程序中的两个函数各自定义一个静态局部变量的话，编译器想汇编器输出的是两个不同名字的局部连接器符号。

使用static修饰模块内部的变量和函数，在其他源文件内是访问不到的，相当于private。没有static修饰的相当于public。

## 21. 加载可执行目标文件

当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制，子进程通过调用execve系统调用启动加载器，加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆栈。然后通过虚拟地址和物理地址的映射，将可执行文件的代码和数据拷贝到内存中。最后加载器跳转到_start函数的地址，最终调用main函数。