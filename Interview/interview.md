# 1 C++

## 1.1 声明和定义

## 1.2 申请二维数组

## 1.3 深拷贝和浅拷贝

- 深拷贝会申请新的内存空间，浅拷贝是将当前指针指向被拷贝对象的内存空间，不会申请新的内存空间。

## 1.4 STL中的vector，list，set，map

- vector的底层实现结构是数组，如果空间不够的话可以成倍地增加空间，如果要在前面的某个位置插入或者删除某个元素会需要很长的操作事件。
- list的底层结构是链表，对于添加元素和删除元素比较方便。
- set和map的底层结构式红黑树，都不允许插入重复元素，map是key--value式的，set的key和value是一个。

## 1.5 std::move的作用

将对象的状态或者所有权从一个对象转移到另一个对象，没有对象内存的拷贝。用途：像C++标准库vector::push_back操作，会对对象进行复制和内存拷贝，通过std::move，可以避免不必要的拷贝操作。

## 1.6 strlen和sizeof的区别

strlen是库函数；sizeof是运算符，在编译时就知道大小。

strlen取决于字符串的长短，sizeof取决于分配空间的大小。

char *s;是指针，sizeof()结果是4，因为指针的大小是5

char s[]；是字符串，sizeof()结果取决于存储字符的数量，即需要分配的空间大小

## 1.7 申请二维数组

先申请指针数组，再对指针数组的每个指针申请内存空间。

## 1.8 虚成员函数

每个声明了虚函数或者继承了有虚=虚函数的类，都会有一个虚函数表，每个实例都会有一个虚函数指针指向这个虚函数表。虚函数表中的每个元素都是函数指针，如果子类覆盖了父类中的虚函数，就会在虚函数表中替代这个虚函数指针。

调用一个虚函数实际上会使用虚函数表中保存的函数地址找到函数后二次调用。如下：

```cpp
class D{
  virtual void f1(){this->fun();}
  void fun(){cout<<"123"<<endl;}
};
D *p=new D();
p->f1();
编译器编译后是这样的：
void f1(D* this){
    (*this->vptr[2])(this);
}
但是不管是在基类还是在父类中，进入这个函数肯定是调用这个类的函数，所以需要压制一下虚拟机制，不通过虚函数表调用虚函数，节省系统开销。如下：
virtual void f1(){D::fun();}
```

### 纯虚函数

virtual void show()=0;

含有纯虚函数的类叫做抽象类，只能被继承，不能生成对象。抽象类不实现纯虚函数，提供一个接口，等待派生类去实现。

### 虚函数的继承

调用一个虚函数需要知道类型、位置。因此每个多肽类上增加两个数据成员：表示class类型的字符串或者数字、执行虚函数表的指针。在编译器，每个对象被放在虚函数表，可以通过索引找到该虚函数；在执行期，传入使用虚函数的对象，通过对象的虚函数指针和索引找到特定的虚函数。

虚函数表中存储的类型：重写的虚函数、继承的虚函数、纯虚函数。

运行时多态的原理：通过对象指针可以找到真正对象的虚函数表，虽然不知道调用父类的虚函数，还是子类的虚函数，但是直到这个虚函数在虚函数表中的某个位置，所以就可以确定调用的是真正对象的虚函数。

### 问题

#### 内联函数、构造函数、静态成员函数、模板函数可以是虚函数吗

inline：内联函数需要在编译器就确定类的信息，但是虚函数实在动态运行时确定的。

static：静态函数没有this指针，虚函数需要依靠this和虚函数表指针来实现。

constructor：虚函数等到运行时才知道调用了哪个对象的虚函数，构造函数时虚函数的话，没有办法构造。在构造函数中调用虚函数，实际执行的时父类的虚函数，因为自己的还没有构造好。

模板函数：类会在虚函数表中存放类中所有虚函数的指针，模板函数如果设计成虚函数，不能到这个模板函数实例了几个虚函数。

#### 为什么需要虚析构函数，什么时候不需要？	父类的析构函数为什么定义为虚函数

一般析构函数时释放内存资源的，析构函数不被调用的话会造成内存泄漏，这样做是为了当用一个基类的指针删除一个派生类的对象时，派生类的析构函数被调用（同时基类的析构函数也会被调用）。

不是要把所有的析构函数写成虚函数，因为当类中有虚函数时，编译器会给类添加一个虚函数表，里面用来存放虚函数指针，这样会增加类的存储空间。<font color=red> 所以，当只有把一个类作为基类的时候，才把析构函数写成虚函数。</font>

```cpp
Base base=new Derived();
delete base;//如果析构函数时虚函数，调用的时Derieved的虚函数，否则调用的是Base的虚函数
```



## 1.9 静态成员函数

静态成员函数不包含这个类的信息，这也就是为什么不能在静态成员函数调用普通类成员。

静态成员函数的主要特征是没有this指针。次要特征为：

- 不能够直接存取所属类的非静态成员函数
- 不能被声明为const、virtual、volatile
- 不需要通过类对象来调用

如果获取静态成员函数的地址，就是获取的他在内存中的地址，因为没有this指针，所以他获取的是“指向非成员函数的指针”，而不是“指向成员函数的指针”。缺乏this指针的静态成员函数，很大程度上等于非成员函数。

## 1.10智能指针

- shared_ptr：使用引用计数实现，内部的引用计数是线程安全的，但是使用对象需要加锁。
  - get：获得原始指针
  - *：解引用
  - reset，参数为空，减少计数；参数不为空，减少原计数，添加新指向。
  - ->：指针方法
  - operator bool，检查是否有效，if(p) ...。等价于return this->get()!=NULL;
  - swap()，交换内部对象
  - unique：return use_count==1；use_count该对象的引用计数；operateor = ，赋值操作增加计数。
  
- weak_ptr

  解决shared_ptr引用成环的问题

  ```cpp
  //实例
  class A{
  public:
      shared_ptr<B> m_ptr_b;
  };
  class B{
      shared_ptr<A> m_ptr_a;
  };
  void test_refer(){
      shared_ptr<A> ptr_a=new A();
      shared_ptr<B> ptr_b=new B();
      ptr_a->m_ptr_b=pb;
      ptr_b->m_ptr_a=pa;
  }
  在执行完test_refer之后，ptr_a和ptr_b析构了，但是CA、CB依旧存在，并且成员m_ptr指向对方，故没办法析构。将其成员改成weak_ptr就不会出现这种情况了。
  ```

  ![](./image/shared_ptr.png)

  - 不能指向原始指针，只能指向shared_ptr指针，也不能将weak对象直接赋值给shared_ptr类型的变量
  - lock：拿到对应的shared_ptr
  - expired：检查指向的对象是否释放
  - swap
  - reset
  - operator=
  - use_count

- unique_ptr：独占资源。

  - get、release、reset、operator*、operator=、operator->、operator bool、swap、get_deleter
  - 跟auto_ptr没什么区别，不能通过拷贝构造和赋值获得所有权，增加了移动语义，std::unique_ptr\<int> p=std::move(p1);
  - 可以作为引用或者指针参数
  - get_deleter：获得unique_ptr对象的删除器
  - unique_ptr可以作为返回值返回，这是因为返回值优化（RVO），就是不返回临时变量，构造返回对象时直接在接收返回对象的空间中构造了。返回有名字的对象叫做具体返回值优化（NRVO）。

## 1.11 函数调用

## 1.12 如果vector为empty的话，begin()和end指向的是哪里

begin()实际上返回的是内存空间的起始点，end()实际上返回的是当前使用内存空间的结束段点。

vector的构造函数时将start和finish设置为0。每次push_back之后，会执行++finish操作。

所以如果vector为空的话，begin()和end()指向的都是内存开始的位置。

## 1.13 执行析构函数的顺序

先构造父类，后构造子类。先析构子类，后析构父类。

# 2 计算机网络
## 2.1 HTTP
 1. http和https的区别
http是传输的是明文，不能传输敏感信息，如银行卡号，密码。端口号一般是80。
htps是SSL+http协议，可以进行加密传输、身份认证。端口号一般是443。
3. HTTP报文 [参考](https://blog.csdn.net/weixin_43327696/article/details/106238866)
 - HTTP的报文格式： **起始行 头部字段** -空行 -**消息正文**
 注：其中**起始行**和**头部字段**称为Header，消息**正文**称为body，Header和body之间一定要有空行隔开。
 -  请求行的格式：请求方法-空格-URL-空格 -版本号-回车换成，请求的头部使用**key:value**更详细的方式说明HTTP报文，我们就是要解析这样的http请求，并发送应答报文给客户端。
 3. HTTP状态码；1.信息，服务器收到请求，需要请求者继续执行。2.成功，操作被成功接收并处理。3.重定向，需要进一步操作以完成请求。4.客户端错误，请求包含语法错误或无法完成请求。5.服务器错误，服务器在处理请求的过程中发生了错误。
## 2.2 TCP
 TCP/IP三次握手和四次挥手 [参考](https://zhuanlan.zhihu.com/p/148070654?from_voters_page=true)
<font color=red> **TCP三次握手**</font>：**1.** 客户端向服务端发送seq=x,syn=1的报文，客户端进入SYN_SEND状态，**2.** 服务端向客户端发送ACK=1,ack=x+1,syn
 =1,seq=y的报文，服务端进入SYN_RECIVED状态，**3.** 客户端给服务端发送ACK=1，ack=y+1，seq=x+1的报文，然后客户端和服务端进入ESTABLISED状态。
**<font color=red>为什么要有要有第三次握手?</font>：如果客户端给服务端发送的SYN分节在网络中等了一段时间，这时候客户端又重新发送了一个SYN分节，如果之前那个分节到达了服务端，就会产生一个错误的连接。
<font color=red>**TCP四次挥手** </font>**1.** 客户端给服务端发送FIN=1,seq=x,客户端进入FIN_WAIT-1状态。**2.** 服务端给客户端发送ACK=1，ack=x+1，seq=y的消息报文。服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT-W状态。**3.** 服务端发送完报文后给客户端发送ACK=1,ack=x+1,FIN=1,seq=z的报文，进入LAST_ACK状态。**4.** 客户端给服务端发送ACK=1,ack=z+1,seq=x+1，客户端进入TIME_WAIT状态，等待2个MSL后进入CLOSED状态，服务端收到消息后进入CLOSED状态。
<font color =red>**问题：为什么客户端最后还要等待2MSL(最长报文寿命)?**</font>
**1.保证客户端发送的最后一个ACK报文到达服务器。** 因为这个ACK报文可能会丢失，站在服务器的角度，已经发了FIN+ACK，然后应该受到ACK报文，如果没有收到，服务器就认为自己发的报文客户端没有收到，就会重新给客户端发送，客户端就能在这个2MSL时间段内收到这个重传报文，然后给出回应报文，并且会重启2MSL计时器。
**2.防止类似于“三次握手”中提到了的“失效的报文”出现在本连接中。** 客户但发送完最后一个报文后，在这个2MSL时间中，就可以保证关于本连接的所有报文段从网络中消失，这样新的连接中就不会旧的请求报文。
<font color =red>**为什么建立连接的时候是三次握手，断开连接的时候是四次握手？**</font>
因为在建立连接受，服务端处在listen状态，收到客户端的SYN后，将SYN和ACK一起发给客户端了。
在断开连接的时候，服务端收到客户端的FIN报文后，只是表示客户不再发送数据了，但是自己的数据可能还没有发送完，需要等自己的数据发送完了再断开连接，就把FIN和ACK分开发了。如果服务端收到FIN报文之前，自己的数据已经发完了，其实也可以把FIN和ACK一起发，成为三次挥手。
<font color=red> **如果建立连接后，客户端出现故障怎么办？**</font>
如果客户端出现状态，服务端肯定不能一直等着，白白浪费资源。TCP还设有一个保活计时器，服务端每次收到客户端的消息后就重置这个定时器，这个定时器的时间通常是两个小时，如果两个小时客户端还没有给服务端发送消息，服务端就会发送一个探测报文段，以后每隔75秒发送一次，一脸发送10个探测报文仍然没有反应，服务端就会认为客户端出了故障，接着关闭连接。

<font color=red>**TCP如何保证可靠传输**</font>
- 分包排序。
- 超时重传+接收端丢弃重复数据。
- 校验和：如果接收端的校验和有误，丢弃这个报文段。
- 利用滑动窗口机制进行流量控制，如果接收方来不及处理发送方的数据，就会提示发送方降低发送速率。
- 拥塞控制：当网络拥塞时，减少数据的发送。
- 停止等待协议：每发完一个分组，就等待对方确认，收到确认后再发下一个分组。

**拥塞控制**
TCP发送方维持一个拥塞窗口，窗口大小取决于网络的拥塞程度，发送方的发送窗口取拥塞窗口和接受方的接受窗口中的较小的那一个。
拥塞控制的四种算法：**慢开始、拥塞避免、快重传和快恢复**。
- 慢开始：发送方将数据缓慢的注入网络，由小到大增加拥塞窗口的数值。cwnd初始值为1，每经过一次往返，cwnd加倍。
- 拥塞避免：让拥塞窗口缓慢增大，每往返一次，cwnd加1。
- 快重传和快恢复：如果接收端接收到不按顺序的包，就会给发送发送一个重复确认，如果发送端接收到三个重复确认，就会立即重传丢失的包。单独包丢失时，FRR能最有效工作，多个包丢失的话就不能很有效的工作了。

**URL请求**
浏览器在和服务器建立一个TCP连接后是否会在HTTP请求完之后断开
答：这个不一定，在HTTP/1.0中，服务器响应完之后，会断开，但是也有一些服务器对connection：keep-alive的Header进行了支持。

<font color=red> TCP和UDP的区别</font>

```cpp
	-在连接方面：TCP是面向连接的，在通信前需要建立连接；UDP是面向无连接的，在通信前不需要建立连接。
	-在可靠行方面：TCP保证信息可靠交付；UDP是尽力交付，不能保证可靠交付。
	-在速度方面：TCP有确认机制，速度慢；UDP只是一直发，不管能不能到，速度快。
	-在连接对象数量方面：TCP只能是一对一；UDP可以一对一，一对多，多对一，多对多服务。
	-在发送QQ消息的时候，使用的是TCP协议；在视频通话的时候用的主要是UDP协议。
```

<font color=red>RST分节 </font>

```cpp
RST表示复位，用来异常的关闭连接。发送RST包关闭连接时，不必等缓冲区都发出，直接丢弃缓冲区的包发送RST包。接收端收到RST包后，也不必发送ACK包来确认。出现RST包的情况：
	-服务器未打开，而客户端来连接。
	-请求超时：比如设置recv的超时时间为100ms，响应超过了100ms就认为接受超时了，就会发送RST拒绝进一步发送数据。
	-提前关闭：数据没读完就关闭连接，就会发送RST分节。
	-向一个关闭的socket上写数据会收到RST分节。比如说服务器关闭了socket，客户端还在向这个socket写数据，就会收到RST分节。
```

## 2.3 输入url，显示主页的过程  
```cpp
	- DNS解析
	- TCP链接
	- 发送HTTP请求
	- 服务器返回HTTP报文
	- 浏览器渲染界面
	- 连接结束
```

 1. dns如何解析出ip
```cpp
	1.查找：浏览器自身-操作系统(hosts)-本地域名服务器(LDNS)-根域名服务器
	2.根域名服务器返回给本地域名服务器LDNS一个主域名服务器的IP地址(gTLD Server如.com,.cn.org等)
	3.本地域名服务器LDNS给返回的主域名服务器gTLD发送请求
	4.主域名服务器根据所给的的域名查找并返回这个域名对应的Name Server，Name Server就是网站注册的域名服务器
	5.Name Server根据映射关系找到目标ip，返回给LDNS
	6.LDNS缓存这个域名和对应的ip地址
	7.LDN把解析的结果返回给用户，用户根据TTL值缓存到本地系统中，解析域名结束
```

2. 两台主机之间如何进行数据传输

   以QQ为例
   	(1)应用层封装，首先应用对消息进行封装：app+消息。识别应用程序。
   	(2)传输层封装：TCP报头+应用数据。
   	(3)网络层封装：IP报头+应用数据。
   	TCP报文包括序号确认号、控制位、校验和等，用来保证可靠传输。
   	TCP报文的源端口号和目的端口号，与源ip地址和目的ip地址唯一确定一条TCP连接。
   	(4)数据链路层：以太网首部+应用数据+以太网尾部。
   	(5)数据到达主机接口，通过网线被传送到另一个主机的接口，然后再一层层的把报头去掉，最后数据到达应用层。

## 2.4 cookie和session

- 因为HTTP协议是无状态的，需要追踪用户的会话，所以就用了cookie和session。不同的是，cookie在客户端，session在服务端。
 - cookie的就是相当于一个身份证，服务端通过response给客户端发一个cookie，客户端每次访问的时候就向服务端提交这个cookie，可以通过javascript:alert(document.cookie)来查看cookie。特征：cookie具有不可跨域名性。
 - session就是服务端把客户端的信息记录在服务期上，每次客户来访问就会查找客户的明细。
 - cookie就是检查cookie的信息来判断客户的身份，session通过检查服务器的客户明细来确定用户的信息。cookie的有效期比较长，但是不安全，session的有效期比较短，但是比session安全。

## 2.5 get请求和post请求的区别

get请求和post请求本质上都是TCP消息，不过get请求把信息访问的信息

# 3 操作系统

## 3.1 进程和线程
进程:资源分配的最小单位，也就是一个运行的程序
线程:程序执行的最小单位，也就是程序的一个单元执行流
线程安全:多个线程对类或者类的方法，同一个文件描述符，或者网络套接字操作的时候按照我们想的一样去做。

## 3.2 孤儿进程
一个父进程已经被终止的进程被称为孤儿进程，那么父进程的id就是1，即init进程id。

## 3.3 保证线程安全的方法
**竞争和原子操作、同步和锁、可重入、防过度化**

- **竞争和原子操作**：linux系统可以提供了一些常用操作的原子指令，确保了线程安全。
- **同步和锁**：在程序里面加互斥锁、读写锁、条件变量、屏障来保证线程安全。
- **可重入**：保证函数可重入可以保证线程安全。
- **防过度优化**：可以加volatile，告诉编译器对访问该变量的代码不进行优化，提供对特殊地址的稳定访问。volatile修饰的关键字，系统总是从他所在的内存中读取关键字。如果不加volatile，不同的线程有可能从内存中读取数据，有可能在寄存器中读取数据。
## 3.4 同步和互斥
互斥是通过竞争独占一个资源，彼此之间不知道对方的存在，执行是乱序的。比如说消费者的各个线程就是互斥，可以用互斥锁实现。
同步时建立在互斥之上，协调多个线程完成同一任务，彼此之间知道对方的存在，执行是有序的。比如说生产者和消费者之间就是同步，可以用互斥锁加条件变量实现。

## 3.5 死锁和避免死锁
①死锁的概念：如果试图对一个互斥量加锁两次，或者一个以上的互斥量相互访问，导致进程无法向前运行，这就是死锁。
②避免死锁：方法1：可以通过仔细控制互斥量的加锁顺序来避免死锁的发生，如果所有线程在对B加锁之前锁住A，就不会发生死锁，可能发生死锁只会在一个线程以相反的顺序对互斥量进行加锁。方法2：可以释放占有的锁，过一段时间再试，这种情况下可以使用pthread_mutex_tryunlock接口避免死锁。方法3：使用pthread_mutex_timedlock设置需要允许阻塞的时间，超时就返回EIMEDOUT，并且解开自己的锁。

## 3.6 互斥锁，mutex
①概念：互斥，线程独自占有，其他线程想占有时阻塞
②函数：

```cpp
pthread_mutex mu=PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_init();//两种初始化方式
pthread_mutex_destroy();
pthread_mutex_lock();
pthread_mutex_unlock();
pthread_mutex_trylock();
```

## 3.7 文件系统

## 3.8 读写锁，也叫共享互斥锁，rwlock

①概念：读写锁有三种模式：读状态加锁，写状态加锁，不加锁。写模式的读写锁允许一个线程占用；读模式的读写锁允许多个线程占用。
②工作方式：当读写锁是写加锁状态，所有对这个锁进行加锁的状态都会阻塞；当读写锁是读加锁状态，所有对这个锁进行读加锁状态的线程都可以访问，所有写加锁状态的线程都会阻塞，直到所有线程都是放他们的读加锁。
③函数：

```cpp
pthread_rwlock_init();//初始化
pthread_rwlock_destroy();//销毁
pthread_rwlock_rdlock();//读加锁
pthread_rwlock_wrlock();//写加锁
pthread_rwlock_unlock();//解锁
pthread_rwlock_tryrdlock();//尝试加读锁，加不上返回错误
pthread_rwlock_trywrlock();//尝试加写锁，加不上返回错误
pthread_rwlock_timerdlock();//超时返回ETIMEDOUT
pthread_rwlock_timewrlock();//超时返回ETIMEDOUT
```
## 3.9 自旋锁

①概念：自旋锁和互斥量类似，但是不是通过休眠使进程阻塞，而是在获得锁之前一直自忙等(自旋)操作。
②用处：锁被持有的时间很短，而且线程并不希望在重新调度上花费太多成本。

## 3.10 记录所，应该说是字节范围锁

可以锁住文件的一个区域或者整个文件，保证一个进程读或者修改文件时，阻止其他进程修改同一文件区。多个进程写加锁和读加锁时互斥的，单个进程新锁会替换旧锁。
建议性锁：建议不阻止；强制性锁：阻止。

## 3.11 I/O多路转接、多路复用

先构造一张有文件描述符的列表，然后调用一个函数，在有准备好的I/O操作时，函数返回，并且告诉进程哪些文件描述符已准备好可以进行I/O操作。

## 3.12 条件变量

①概念：互斥量必须在锁定之后才能改变条件
②函数：

```cpp
pthread_cond_t cont=PTHREAD_COND_INITIALIZER;
pthread_cond_init();//两种初始化方式
pthread_cond_destroy();
pthread_cond_wait(cond,mutex);
pthread_cond_timewait(cond,mutex,timesp);
//wait函数的作用：释放mutex，等待cond的信号

pthread_cond_singal(&cond);//唤醒一个进程
pthread_cond_broadcast(&cond);
```

​	③条件变量存在的意义：如果直接使用mutex，除了生产者、消费者之间需要竞争互斥量之外，消费者之间也需要竞争互斥量，如果队列中没有数据，那么消费者之间竞争互斥锁是没有意义的。有了条件变量机制后，只有生产者完成生产吗，才会引起消费者之间的竞争，提高了程序效率。

## 3.13 信号
是一种软件中断。Ctrl+C产生中断信号SIGINT。 
kill 命令是向内核发送终止信号。

## 3.14 屏障

①概念屏障是用户协调多个线程并行工作的同步机制。屏障允许某个线程等待，知道所有线程都到达某一点，然后从该点执行。pthread_join就是一种屏障，允许一个线程等待，知道另一个线程退出。
②函数

```cpp
pthread_barrier_init(barrier,attr,count);//初始化屏障,可以指定count，表明在允许所有线程继续工作之前，必须到达屏障的线程数目
pthread_barrier_destory(&barrier);//销毁屏障
pthread_barrier_wait(&barrier);
//表明线程已经完成工作，准备等所有的其他线程赶上来。
//调用pthread_barrier_wait()的线程在屏障技术(pthread_barrier_init时设定)未满足条件时，会进入休眠状态，如果该线程是最后一个调用pthread_barrier_wait()的线程，就满足了屏障计数，所有的线程都会被唤醒。
//对于任意一个线程，pthread_barrier_wait的返回结果是PTHREAD_BARRIER_SERIAL_THREAD，其他线程的返回值是0，这就使得一个线程可以作为主线程，处理其他线程的工作结果。
```

## 3.15 使用线程的过程

```cpp
pthread_t tid;
pthread_create(tid,NULL,fun,arg);
void* fun(void* arg);
pthread_join(tid,NULL);
```
## 3.16 散布读(readv)和聚集写(writev)

用于在一次函数调用中读、写多个非连续缓冲区。

```cpp
函数
#include<sys/uio.h>
ssize_t readv(int fd,const struct iovec *iov,int iovent);
ssize_t writev(int fd,cosnt struct iovec *iov,int iovent);
struct iovec{
void *iov_base;//缓冲区的开始地址
size_t iov_len;//缓冲区的长度
}
```
## 3.17 函数readn和writen

本质：调用read和write直至读写了n个字节。

## 3.18 守护进程

守护进程是一种生存期长的进程，通常执行系统的日常事务。比如说系统守护进程：syslogd，login，网络守护进程sendmail，httpd等。

## 3.19 你理解的操作系统

控制计算机硬件的一个软件

##  3.20 用户态和内核态

- 区别：内核态运行操作系统程序，操作硬件；用户态运行用户程序。
- 指令划分：特权指令是只能操作系统使用，用户程序不能使用的指令，如I/O、内存清零；非特权指令是用户程序可以使用的指令，如控制转移，算术运算。
- 特权级别：R0，R1，R2和R3。R0相当于内核态，R3相当于用户态。
- 转换后：用户态->内核态，通过中断、异常、陷入机制(访管指令)；内核态->用户态，通过设置程序状态字PSW。
- 联系：一个进程在执行用户自己的代码的时候处于用户态。如果执行文件的读写操作、网络数据的收发，这些系统调用会调用内核的代码，就会处于内核态。
- 用户态切换到内核态的三种方式：1.系统调用，这是用户态主动切换到内核态的方式，比如说fork()执行了个创建新进程的系统调用，malloc执行了sbrk的系统调用。2.异常，CPU在执行用户态下的程序是，发生了一些一场，会触发当前运行进程到处理此异常的内核相关进程中，比如说缺页异常。3.外围设备的中断。
## 3.21 什么是系统调用

系统调用是应用程序和系统间的接口。比如说malloc调用了sbrk来申请内存，printf会调用write系统调用以输出一个字符串。

## 3.22 malloc和free的原理
malloc先遍历堆中的内存是否可用，如果可用并且大小符合就直接用，如果不能用的话就向操作系统中申请新的内存。
free把内存归还给操作系统。

## 3.23 系统调用和库函数的区别：

系统调用是由内核实现的，库函数是从用户角度实现的，有时候库函数会调用系统调用。

## 3.24 进程和线程区别

- 进程是资源分配的最小单位，线程是cpu调度的最小单位。
- 线程必须在进程先运行；一个进程可以包含多个进程。
- 不同进程之间很难共享数据；同一进程下的不同线程很容易共享数据，当线程共享一个内存时，可以加互斥锁。

## 3.25 什么是协程

## 3.26 进程间通信方式

## 3.27 阻塞I/O、非阻塞I/O

阻塞I/O：每个用户一个线程，线程会等待用户I/O操作，I/O操作完之后才会继续执行。
非阻塞I/O：一个线程服务多个用户，线程给用户注册一个回调函数，用户完成I/O操作后执行回调函数。

## 3.28 对于I/O密集型程序，最佳线程数=cpu核数*（1/cpu利用率）=cpu核数*（1+i/o耗时/cpu耗时）

## 3.29 操作系统由哪些构成

操作系统由内核、驱动程序、接口库、文件系统、外围组成。其中最重要的内核由进程调度、内存管理、网络接口、虚拟文件系统、进程间通讯五部分组成。

## 3.30 进程的状态、切换、调度

- 状态
	- 就绪：进程具备运行条件，等待系统分配处理器就可以运行。
	- 执行：进程占有处理器正在运行。
	- 阻塞：进程不具备运行条件，正在等待某个事件完成，比如说等待互斥量解锁。
- 状态的切换：
	- 就绪->运行：就绪状态的进程，当进程调度程序分配了处理器后，就变为运行状态。
	- 执行->就绪：处于执行状态的进程，由于分配给他的时间片用完了，必须让出处理器，就变为就绪状态了。
	- 执行->阻塞：处于执行状态的进程因为等待某个事件发生无法继续执行，就变成阻塞状态。
	- 阻塞->就绪：阻塞状态的进程，若其等待的时间已经发生，于是进程由阻塞状态变为就绪状态。
## 3.31 操作系统中的进程调度算法

- 先来先服务调度算法
- 短作业优先调度算法
- 高优先权优先调度算法
- 高响应比优先调度算法
- 时间片轮转法
- 多级反馈队列调度算法：①设置多个就绪队列，第一个优先级最后，然后优先级一次降低。②有新进程来了将新进程放在第一个就绪队列的末尾，如果正在执行的进程能执行完，就撤离系统，如果执行不完就放在下一个就绪队列的末尾。③如果前面的就绪队列为空，并且有新进程来了，那么就将正在这执行的进程放在这个就绪队列的末尾，去执行新的进程。
## 3.32 进程间通信方式（共享内存、管道、消息）

## 3.33 线程的实现方式（一对一、多对一等）

## 3.34 互斥与同步（信号量、管程、锁）

## 3.35 并发经典的问题：读者写者、哲学家就餐问题

## 3.36 为什么需要虚拟内存，MMU 具体如何做地址转换的

## 3.37 内存为什么分段、分页

## 3.38 页面置换算法

## 3.40 文件系统是如何组织的

## 3.41 虚拟内存

- 虚拟内存
[参考](https://www.jianshu.com/p/415618863d52)
	- 现代处理器的寻址方式：程序虚拟寻址。CPU生成的虚拟地址在传送给主存之前被翻译成一个物理地址。地址翻译需要CPI硬件和操作系统共同管理，CPU上的叫做内存管理单元，利用查询表翻译虚拟地址，查询表由操作系统管理。
	- 程序和虚拟内存的关系：因为一个程序是逐段执行的，将需要执行的程序从硬盘中复制到内存中，其他不运行的程序保存在硬盘里。经过有目的的换入换出，处理器就可以运行一个大于实际物理内存的程序。也就是说处理器好像拥有了一个大于实际屋内空间内存的内存空间，这个储存空间叫做虚拟内存，真正的内存空间被称为实际物理内存空间。
	- 映射：由于存在两个地址，因此一个应用程序从编写到执行，需要进行两次映射。第一次映射是到虚拟内存空间；第二次映射是到物理内存空间，第二次映射是有硬件和软件共同完成的，硬件部分是储存管理单元，软件部分是操作系统的内存管理模块。
	- 虚拟地址/物理地址表格：用来映射虚拟地址和物理地址，操作系统的内存管理模块建立，以虚拟地址位索引，记录了程序段所占用的物理地址，是硬件的存储管理单元将虚拟地址转换为实际物理地址的依据。
	- 技术关键：程序映射表
- linux的虚拟内存技术
	- 页和页框：linux将虚拟空间分为若干个大小相等的存储分区，成为页；然后按页的大小划分为若干块。物理内存中的块叫做页框。页与页块是linux实现虚拟内存技术的基础。页和页框的带下一般是4kB，根据系统和应用的不同，也和页框页可能会变化。高位段是页和页框的编码，低位段时页和页框的偏移量。
	- 在将一个页映射到某个页框上的同时必须将页码和对应的页框码填入映射记录表中。
	- 进程和虚拟空间：每个进程都有自己的4G空间，新进程建立的时候会建立自己的内存空间，进程的数据、代码等会从磁盘拷贝到自己的进程中间，每个进程分配的内存空间都会与对应的磁盘空间映射。每个进程的4G空间实际上时虚拟内存空间，每次访问内存空间的地址都需要将地址翻译为实际物理内存地址。
	- 页表：所有进程共享同意物理内存，每个进程只把自己目前所需的虚拟内存空间映射到物理内存上。进程需要知道那些内存地址上的数据在物理内存上，哪些不在，在物理内存上的哪里，因此需要页表来记录。页表中的每一个表项分为两部分，第一部分记录此页是否在物理内存上，第二部分记录物理内存页的地址。
	- 缺页异常：当进程访问某个虚拟地址时会去查看页表，如果发现对应的数据不在物理内存上则出现缺页异常。缺页异常的处理过程是将进程所需要的数据从磁盘拷贝到物理内存中，如果内存已满没有空余位置，就回去找一个页进行覆盖，如果覆盖过的页曾经被修改过，需要将此页写回磁盘。
- 优点：利用碎片，使用库文件的代码，可以只储存一份这样的代码
- 进程加载时，内核只是位进程创建了虚拟内存的布局，具体是初始化进程控制表中内存相关的链表，不直接拷贝到物理内存，只建立虚拟内存和物理内存的映射，等运行相关程序时，才会通过缺页异常来拷贝数据，进程运行过程中需要动态分配内存，比如malloc也只是分配了虚拟内存，也就是虚拟内存对应的也白哦项的相关设置，进程真正访问到此数据时才引发缺页异常。
## 3.42 虚拟文件系统

- 引论：虚拟文件系统屏蔽了不同文件系统的操作差异和实现细节，提供了统一的实现框架和操作接口，降低了操作文件和接入新文件系统的难度。
- 虚拟文件系统是内核的一个软件层，给用户的程序提供文件系统接口；同时它也提供了内核中一个抽象的功能，允许不同的文件系统共存。借用虚拟文件系统可以是应用open、read、write这些系统调用操作文件。
- 比如说ret=write(fd,buf,len);首先会调用虚拟文件系统的通用系统调用sys_write()；接着sys_write()会根据fd找到所在文件系统提供的写操作函数op_write()，最后调用文件系统的写操作函数op_write()。
- 四种对象类型：①超级块对象：代表一个已安装的文件系统；②索引节点对象：代表具体文件；③目录项对象，代表哦一个目录项，是文件路径的一个组成部分；④文件对象：代表进程打开的文件。

## 3.43 exit和_exit

exit先执行一些清理，饭后返回内核:_exit直接返回内核。

## 3.44 为什么有了close之后，还是用shutdown呢？

- 首先，只有最后一个活动引用关闭时，close才释放网络端点。这意味着如果复制一个套接字，要直到关闭了最后一个引用他的文件描述符才释放这个套接字。而shutdown允许一个套接字处于不活动状态，和引用它的文件描述符数目无关。
- 其次，游客可以很方便地关闭一个套接字传输中的一个方向。例如，如果想让所通信端的进程能够确定数据传输何时结束，可以关闭该套接字的写端然后通过该套接字的读端仍可以继续接受数据。
## 3.45 进程标识

网络地址：端口号

## 3.46 字节序

处理器架构特征，用来指示像整数这样的大数据类型内部是如何排序的。分为：大端字节序：就是高位放在低地址上；小端字节序，低位放在低地址上。TCP/IP协议栈是使用的大端字节序。

## 3.47 指数补偿

在客户端connect服务端的时候，如果出现错误，进程会休眠一段时间，这个时间是指数级别的增加，直到到达一个阈值，关闭连接的套接字。

## 3.48 IO模型

同步IO，异步IO，阻塞IO，非阻塞IO(以下都使用linux下的recv作为例子) [参考知识](https://www.cnblogs.com/felixzh/p/10345929.html)

- **阻塞IO模型**：使用recv的默认参数一直等数据，直到拷贝到用户空间。**这种IO模型是同步的。** like：水龙头没有水，A同学需要等水装满杯子才能去做其他的事情。
- **非阻塞IO模型**：使用recv，改变flags，不管有没有获取到数据都返回。**这种IO模型也是同步的。** 水龙头没水，B同学等一会儿再过来看。这种情况下离开了装水现场(回到了用户空间)。
- **IO复用模型**：调用recv前调用select或者epoll，网络数据到达内核后，内后告诉用户进程。**期间阻塞与select或者epoll，没有阻塞于recv，也可以叫做非阻塞IO，同步IO。** C同学告诉阿姨看水龙头，水龙头有水了，阿姨告诉C同学，C同学去接水。
-  **信号驱动IO模型**：通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数。D同学让舍管阿姨等有水的时候取通知他接水(注册信号函数)，D同学得知有水了，去接水(执行信号函数)。
- **异步IO模型**：调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行实现制定好的函数。E同学让舍管阿姨将杯子装满水后通知他，整个过程E同学都可以做别的事情，**这是真正的异步IO。**[参考异步IO实现](https://blog.csdn.net/zhxue123/article/details/21087165)
- 总结：![在这里插入图片描述](https://img-blog.csdnimg.cn/20210116220521891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dvYWl3b2ppYTY2OTk=,size_16,color_FFFFFF,t_70)

## 3.49 线程间通信的方式

- 无名管道：速度慢、容量有限，并且只能在有关系的进程间通信。
- 命名管道：命名管道可以在任何进程间通信，但是速度满。
- 消息队列：消息队列就是一个链接表，一个消息由一个标识符来标识。
- 信号量：不能传递复杂消息，只能用于同步。
- 共享内存：速度快，但是要保持同步，比如一个写的时候，另一个要注意读写的问题，相当于线程间的线程安全。

## 3.50 协程

协程是比线程更加轻量级的存在。一个线程可以有多个协程，实现方式是线程创建几个执行体，给他们各自指定执行入口，申请一些内存给他们作为执行栈，那么线程就可以按需调度这几个执行体了，同时线程会记录执行体的ID、栈的位置、执行入口地址、执行现场等。协程是程序控制的，不用操作系统去管理，也被称为用户态线程，不会像线程切换那样消耗资源。

## 3.51 select/poll/epoll的底层实现原理

## 3.52 创建进程的一个流程



# 4 数据库



# 5 数据结构
## 5.1 解决哈希表冲突

哈希冲突：算出来的哈希值的地址被占了

- 开放寻址法
	- a.线性探测法：插入数据时如果冲突就往后找空闲的位置放；寻找数据时，依次往后对比，如果遍历到空闲位置还没有找到，就说明不在集合里。删除后标记一下deleted。
	- b.二次探测：二次探测的步长标为原来的平方。
- 再哈希法：冲突就再次哈希。
- 链表法：每个桶对应一个链表，插入的时候直接查到表头，插入的实践复杂度时O(1)，查找删除的时间复杂度时O(k)，k表示链表的节点数。如果哈希冲突比较多的话可以利用红黑树代替链表。
- 建立公共溢出区：把和表冲突的元素，一律放到溢出区。
## 5.2  平衡二叉树、B树、B+树、B*树
 [参考博文](https://blog.csdn.net/v_july_v/article/details/6530142)
 - 1.平衡二叉树：二叉树、左孩子<根节点<右孩子、左右子树的高度差小于1、没有重复值
 - 2.B树(B-树)
 	- 特性：B树的分支因子比较大，可以在时间logn的内快速的插入和删除节点，当B树有N个关键字，m阶时，其最大高度是**$log_{m/2}^{(N+1)/2}+1$**
 	- 特点：
	 	- 1.左小右大；
	 	- 2.非叶子节点的子结点树>1，且<=M，并且M>=2，空树除外，M是M个搜索路径
	 	- 3.枝节点的关键字数量大于ceil(M/2)-1个，且小于M-1个
	 	- 4.所有叶子节点均在同一层，叶子节点除了包含了关键字和关键字记录的指针，也有指向其子结点的指针，不过是这项null，对应下一层
- 3.B+树
		- B树的异同点：1.n棵子树对一个n-1个关键字； 2.所有的叶子节点包含了全部关键字的信息；3.所有非终端节点可以索引部分。
		- 为什么用B+树作为索引：1.B+树磁盘读写代价更低，因为他的内部节点没有指向关键字具体信息的指针；2.B+树查询效率更稳定，因为他的非终节点不是指向文件内容的节点，所有的查询都有从根节点走向叶子节点，这样每次查询的效率都相当。
- 4.B\*树		
		- 特点：空间使用率高，要求块的使用率为2/3；增加了指向兄弟节点的指针，
		- B+树的分裂：当一个节点满时，分出1/2到一个新的节点，父节点在增加一个指向这个节点的指针。
		- B\*树的分裂：当一个节点满时，如果下一个兄弟节点没有满，将一部分数据移到兄弟节点中，再在原节点中插入关键字，最后修改父节点的关键字；如果下一个兄弟节点满了，就在中间创建一个新的节点，原节点和兄弟节点各迁出1/3到新节点，最后在父节点中创建指向新节点的指针。
		 注：B*树创建新节点的概率比B+树创建新节点的概率要低，空间使用率要高。
注：平衡二叉树要尽量避免成为链表，一般用红黑树实现

## 5.3 红黑树的插入

1. 数为空，直接插入

2. 存在该结点，直接更新

3. 父节点为黑，直接插入

4. 父节点为红

   4.1 父红+叔叔红，变色，把爷爷结点当作插入结点

   4.2 父红+叔叔黑或不存在

   ​	4.2.1 父亲是左节点

   ​		4.2.1.1 插入结点时左节点，对爷爷右旋，父变黑，爷爷变红

   ​		4.2.1.1 插入结点时右节点，对父右旋，爷爷右旋，父变黑，爷爷变红（称为对于插入结点来说的）

   ​	4.2.2 父亲是右节点

   ​		类似父亲是左节点 		

   



# 6 算法

## 6.1 判断数组是否有三个递增元素(不要求连续)

## 6.2 拓扑排序

依赖关系，如结构体之间的依赖关系。

将入读为0的结点放入队列，然后弹出并将下一个结点放入队列，直到队列为空



# 7. 项目

## 1.详细介绍webserver项目

这是一个基于Reactor模型的web服务器，使用的技术有非阻塞IO、事件驱动、多缓冲区异步日志、线程池、基于小根堆的定时器，可以解析post和get请求，然后我用webbench压测以下，短连接的吞吐量可以达到4Mbit/s，长连接的吞吐量可以到达7Mbit/s。

## 2.非阻塞IO怎么实现的

使用fctl将套接字设置成非阻塞IO，就是执行后立即返回，而不是阻塞。然后将有写请求的套接字注册到epoll中，可以写的时候就调用对channel注册的回调写函数。

## 3.select/poll/epoll的区别和实现原理

select的32位机器上的最大连接数目默认是1024，64位机器上的最大连接数目是2048

### 相同点：都是同步的IO多路复用

### 区别

select：单进程可以打开fd有限制；有事件发生时需要轮询；用户空间和内核空间的复制非常消耗资源。

poll：采用链表的方式替换fd_set的数据结构，而使其没有连接数的限制。

epoll：时间复杂度时O(1)。有LT模式：就绪事件一次没有处理完就会一直处理。ET模式：就绪事件只能处理一次，若没有处理完会再下次的其他时间就绪时再进行处理，同时为了保持数据的完整性，只支持非阻塞的读写。

### select原理

进程通过驱动程序访问设备时，若没有数据可读/可写，就将该用户进程插入到设备驱动对应的等待队列让其睡眠，在有数据时将其唤醒。使用bitmap存储fd。

### poll原理

poll和select的区别不大，但是是用链表存储套接字，没有最大连接数目的限制。

### epoll原理

调用epoll_create时，内核会帮我们再epoll文件系统里创建一个file结点，再内核缓存里创建一个红黑树存储注册的socket和就绪链表存储准备就绪的事件，当epoll_wait调用时，只需要观察这个双向链表就可以。

就绪链表得到就绪事件的方式是将所有添加到epoll的事件与驱动程序建立回调关系，相应的事件发生时会调用这个回调方法，这个回调方法在内核中叫做epoll_callback，这个回调方法会把事件放入就绪链表中。

## 4.多线程、锁的问题

程序中有一个主线程接收sockfd，然后以round robin的方式分发给子线程，主线程和子线程之间会存在锁的争用，用来维护子线程的任务队列。

## 5.线程池

# 8. 实习

封装人脸模型SDK用到的技术

就是将训练好的模型封装成SDK，让用户对其进行调用。

# 9. linux

## 1.export的作用

设置环境变量

## 2. 查找

find . -name "txt"

grep -r "txt" .

# 其他链接
[知乎_腾讯](https://zhuanlan.zhihu.com/p/274473971)
[github_综合](https://github.com/0voice/interview_internal_reference)
[面经+学习路线](https://mp.weixin.qq.com/s/7xANFCFUd528Lch3lqcbRg)


​    


​     