# 零、框架简介

## 1.动态规划框架

明确 [状态] -> 定义 dp 数组/函数的含义 -> 明确 [选择] ->明确 [base case]

## 2.回溯算法框架

做选择 -> 去递归 ->撤销选择

```cpp
def backtrack(路径，选择列表)
    if base case
        添加路径
        return；
    
    for 选择 in 选择列表
        将选择添加到路径，视情况erase选择列表
        backtrack(路径，选择列表)
        撤销选择，视情况insert选择列表
```

## 3.bfs框架

队列(剥洋葱)、哈希表(去重)

剥一层(i:size)，步数加1。遍历到直接返回。

```cpp
int bfs(Node start,Node end){
    queue q;
    set s;
    q.push(start);
    s.push(start);
    int step=0;
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size();i++){
            Node t=q.top();
            q,pop();
            if(t==end) return step;
            for(auto x:t.adj()){
                q.push(x);
                s.push(x);
            }
        }
        step++;
    }
    return -1;
}
```

## 4.二分查找

查找某个数：left=0,right=nums.size()-1；循环条件left<=right；缩小边界left=mid+1,right=mid-1。

查找左边界：left=0，right=nums.size()；循环条件left<right；缩小边界left=mid+1,right=mid；返回left。

查找右边界：left=0，right=nums.size()；循环条件left<right；缩小边界left=mid+1,right=mid；返回left-1。

## 5.滑动窗口

```cpp
int left=0,right=0;
while(right<s.size()){
    window.add(s[right]);
    right++;
    while(windows needs shrink){
        window.remove(s[left]);
        lfet++;
    }
}
```



# 一、刷题记录

## 1.汇总

1. 股票：状态转移dp\[i]\[j][s]表示第i天，有j-1次交易的能力，状态是s的最大利润。注意要考虑i=-1的时候，因为\[i][j]和\[i-1][j-1]有关系。如果j为1或者无穷大时，不需要考虑i=-1的情况。

   打家劫舍：使用递归将进行动态规划。[0,prices.size()-1]、[0,prices.size()-2] && [1,prices.size()-1]、选择父节点 or 不选择父节点

2. 编辑距离

   区间：删除被覆盖的区间（可以重叠，起点递增，删除i后面覆盖的元素）、无重叠区间（不可以重叠，终点递增、删除i后面重叠的元素）

   背包

3. 背包

4. 反转链表

## 2.剑指offer



## 3.具体题目

##

### 





# 二、经典题目代码

## 1.堆排序

```cpp
#include<iostream>
#include<vector>
using namespace std;
//堆排序,所有的父节点调整（len/2-1），大的放后面，再调整
void exchange(int& a,int& b){
    int temp=a;
    a=b;
    b=temp;
}
void adjust(vector<int>& nums,int i,int end){
    int dad=i;
    int son=2*i+1;
    while(son<=end){
        if(son+1<=end&&nums[son]<nums[son+1])
            son++;
        if(nums[dad]<nums[son])
            exchange(nums[dad],nums[son]);
        dad=son;
        son=2*dad+1;
    }
}

void heap_sort(vector<int> &nums){
    int len=nums.size();
    for(int i=len/2-1;i>=0;i--)
        adjust(nums,i,len-1);
    for(int i=len-1;i>0;i--)
    {
        exchange(nums[0],nums[i]);
        adjust(nums,0,i-1);
    }
}

int main(){
    vector<int> nums{1,3,4,5,2,8,6};
    heap_sort(nums);
    for(int i=0;i<nums.size();i++)
        cout<<nums[i]<<" ";
}

```

## 2.归并排序

```cpp
#include<iostream>
#include<vector>
using namespace std;
void merge_sort(vector<int>& nums,vector<int>& reg,int start,int end){
    if(start>=end) return ;
    int mid=start+(end-start)/2;
    int start1=start,end1=mid;
    int start2=mid+1,end2=end;
    merge_sort(nums,reg,start1,end1);
    merge_sort(nums,reg,start2,end2);

    int t=start;
    while(start1<=end1&&start2<=end2)
        reg[t++]=nums[start1]<nums[start2]?nums[start1++]:nums[start2++];
    while(start1<=end1)
        reg[t++]=nums[start1++];
    while(start2<=end2)
        reg[t++]=nums[start2++];
    while(start<=end)
        nums[start]=reg[start++];
}
int main(){
    vector<int> nums{1,2,5,3,4,9,8};
    vector<int> reg(nums.size(),0);
    merge_sort(nums,reg,0,nums.size()-1);
    for(int i=0;i<nums.size();i++)
        cout<<nums[i]<<" ";

}

```

## 3.k段归并排序

```cpp
#include<iostream>
#include<vector>
using namespace std;
void exchange(int& a,int& b){
    int temp=a;
    a=b;
    b=temp;
}
//调整败者树：s对应的节点和父节点相比，如果败就交换，直到到达根节点，ls[0]是最小的
void adjust(vector<int>& b,vector<int>& ls,int s,int k){
    int t=(s+k)/2;
    while(t>0){
        if(b[s]>b[ls[t]])
            exchange(s,ls[t]);
        t/=2;
    }
    ls[0]=s;
}
//创建ls：初始化b、从b最后一个节点到第一个节点初始化ls
void creatls(vector<int>& b_,vector<int>& ls,int k){
    vector<int> b(k+1,-1);
    for(int i=0;i<b_.size();i++)
        b[i]=b_[i];
    for(int i=k-1;i>=0;i--)
        adjust(b,ls,i,k);//改变b[i]后对应调整的树

}
//合并：取出队列头、判空、调整
void kmerge(vector<vector<int>>& nums,vector<int>& b,vector<int>& ls,int k){
    vector<int> index(k,0);
    int s=ls[0];
    while(b[s]!=INT_MAX){
            cout<<nums[s][index[s]]<<" ";
            index[s]++;
            if(index[s]>=nums[s].size())
                b[s]=INT_MAX;
            else b[s]=nums[s][index[s]];
            adjust(b,ls,s,k);
            s=ls[0];
    }
}
int main(){
    int k=3;
    vector<vector<int>> nums{
        vector<int>{1,2,4,6,8},
        vector<int>{1,3,6,7,9},
        vector<int>{2,4,5,7,8},
    };
    vector<int> b(k,0);
    for(int i=0;i<b.size();i++)
        b[i]=nums[i][0];
    vector<int> ls(k,k);
    creatls(b,ls,k);
    kmerge(nums,b,ls,k);

}
```

