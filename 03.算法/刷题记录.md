# 框架简介

## 1.动态规划框架

明确 [状态] -> 定义 dp 数组/函数的含义 -> 明确 [选择] ->明确 [base case]

## 2.回溯算法框架

做选择 -> 去递归 ->撤销选择

```cpp
def backtrack(路径，选择列表)
    if base case
        添加路径
        return；
    
    for 选择 in 选择列表
        将选择添加到路径，视情况erase选择列表
        backtrack(路径，选择列表)
        撤销选择，视情况insert选择列表
```

## 3.bfs框架

队列(剥洋葱)、哈希表(去重)

剥一层(i:size)，步数加1。遍历到直接返回。

```cpp
int bfs(Node start,Node end){
    queue q;
    set s;
    q.push(start);
    s.push(start);
    int step=0;
    while(!q.empty()){
        int size=q.size();
        for(int i=0;i<size();i++){
            Node t=q.top();
            q,pop();
            if(t==end) return step;
            for(auto x:t.adj()){
                q.push(x);
                s.push(x);
            }
        }
        step++;
    }
    return -1;
}
```

## 4.二分查找

查找某个数：left=0,right=nums.size()-1；循环条件left<=right；缩小边界left=mid+1,right=mid-1。

查找左边界：left=0，right=nums.size()；循环条件left<right；缩小边界left=mid+1,right=mid；返回left。

查找右边界：left=0，right=nums.size()；循环条件left<right；缩小边界left=mid+1,right=mid；返回left-1。

## 5.滑动窗口

```cpp
int left=0,right=0;
while(right<s.size()){
    window.add(s[right]);
    right++;
    while(windows needs shrink){
        window.remove(s[left]);
        lfet++;
    }
}
```



# 刷题记录

1. 股票：状态转移dp\[i]\[j][s]表示第i天，有j-1次交易的能力，状态是s的最大利润。注意要考虑i=-1的时候，因为\[i][j]和\[i-1][j-1]有关系。如果j为1或者无穷大时，不需要考虑i=-1的情况。

   打家劫舍：使用递归将进行动态规划。[0,prices.size()-1]、[0,prices.size()-2] && [1,prices.size()-1]、选择父节点 or 不选择父节点

2. 编辑距离

   区间：删除被覆盖的区间（可以重叠，起点递增，删除i后面覆盖的元素）、无重叠区间（不可以重叠，终点递增、删除i后面重叠的元素）
   
   背包

3. 背包