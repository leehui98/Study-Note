题目描述：

一个链表的节点由val、next、random组成，分别表示当前节点的值，下一个节点，随机指向的一个节点。

题目要求：创建一个链表，并对这个链表进行深拷贝（新链表的结点中的random指针指向的元素是原链表对应节点的新节点）。

思路：使用unordered_map<node*,node\*>记录新旧结点的对应关系，创建完新链表后，用t遍历链表中的每个结点，memo[t]是新链表中t对应的新结点，需要设置memo[t]的random指针，旧链表结点t的random指向的是t->random，对应的新节点是memo[t->random]。

实现：

```cpp
#include<iostream>
#include<vector>
#include<unordered_map>
using namespace std;
struct node
{
    int val;
    node* next;
    node* random;
    node(int val_):val{val_},next{NULL},random{NULL} {}
};
unordered_map<node*,node*> memo;
node* create(vector<int> nums)
{
    node* head=new node(nums[0]);
    node* t=head;
    t->random=head;
    for(int i=1; i<nums.size(); i++)
    {
        t->next=new node(nums[i]);
        t->random=t;
        t=t->next;
        t->random=head;
    }
    return head;
}
node* show(node* head)
{
    node* t=head;
    while(t)
    {
        cout<<t->val;
        t=t->next;
    }
}
node* cop(node* head)
{
    node* t=head->next;
    node* newhead=new node(head->val);
    memo[head]=newhead;//这里是newhead，而不是memo[newhead]
    node* newt=newhead;
    while(t)
    {
        newt->next=new node(t->val);
        memo[t]=newt->next;
        t=t->next;
        newt=newt->next;
    }

    t=head;
    while(t)
    {
        memo[t]->random=memo[t->random];
        t=t->next;
    }
}
int main()
{
    vector<int> nums{1,2,3};
    node* head=create(nums);
    node* newhead=cop(head);
    show(newhead);
}

```

