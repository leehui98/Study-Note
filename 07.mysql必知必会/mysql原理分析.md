专栏主线：事务、索引、锁等内容。

# 0.知识点

1. MyISAM和InnoDB的区别

   MyISAN不支持事务、行锁，实现并发只能使用表锁。

   InooDB支持。

# 1. 基础架构：一条SQL查询语句是如何执行的

大体来说：MySQL分为Server层和存储引擎层。

![](./image/mysql逻辑架构.png)

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

MySQL默认的存储引擎是InnoDB。也可以在创建表的时候指定存储引擎。create table 语句中使用engine=memory。

## 连接器

第一步，通过连接器连接到这个数据库上，连接器负责跟客户端建立连接、获取权限、维护和管理连接。命令如下

```mysql
mysql -h$ip -P$port -u$user -p
```

密码也可以直接跟在-p后面，但是可能会导致泄漏，如果连接的是生产服务器，最好不要这样做。

show processlist命令可以看到连接。

客户端长时间没有动静，就会断开他。有参数wait_timeout来控制，默认是8小时。

如果连接断开后，客户端再次发送请求，会受到一个错误提醒：lost connection to MySQL server during query。如果要继续，就要重连。

如果有太多长连接，就会导致内存占用太大，被系统强制杀掉，也就是MYSQL异常重启。

解决办法：定时断开长连接、或者通过执行mysql_reset_connection来重新初始化连接资源。

## 查询缓存

连接建立完成后，就可以是使用select语句了。执行逻辑就会来到第二部：查询缓存。

如果缓存找不到，去下面找。

通常情况下，不建议使用查询缓存，因为查询缓存失效非常频繁，只要对一个表更新，这个表上的查询缓存都会被清空。对于更新业务大的数据库来说，查询缓存的命中率会非常低。除非业务有一张静态表，很长时间才更新。

可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句不使用缓存。确定使用查询缓存的时候，可以用SQL_CACHE显式指定。如:

```mysql
select SQL_CACHE * from T where id=10;
```

注意MYSQL8.0直接把这个功能给删掉了。

## 分析器

对SQL语句进行解析，生成解析树，查看有没有相应的表和字段。

## 优化器

优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多个表关联的时候，决定各个表的顺序

## 执行器

分析器直到要做什么，优化器直到应该怎么做，执行器开始执行语句。

执行器调用存储引擎的相关接口，生成结果集返回给用户。

可以在数据库的慢查询日志中看到一个row_examined的字段，表明语句执行过程中扫描了多少行。

# 2.日志系统：一条SQL更新语句是如何执行的

更新流程和查询流程类似，不一样的是涉及两个日志模块：redo log（重做日志）和binlog（归档日志）

## redo log

MYSQL的日志使用了WAL技术，关键点是先写日志，再写磁盘。

当一条记录需要更新时，InnoDB引擎会先把记录写道redo log里面，并更新内存，同时InnoDB会在系统比较空闲大的时候，将这个操作记录写道磁盘里面。

InnoDB的redo log是固定大小的，比如可以配置4个文件，每个文件的大小是4GB，从头写到尾，写到末尾就又回到开头循环写。擦除记录前要把记录更新到数据文件。

有了redo log，InnoDB就可以保证数据库发生异常重启的时候，之前提交的记录都不会丢失，这个能力称为crash-safe。

## bin log

bin log和redo log的区别

1. binlog是Server层的日志，所有引擎都可以使用；而redo log是InnoDB特有的。
2. redo log是物理日志，记录的是在某个数据页上做了什么修改；bin log是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID为2这一样的c字段加1”。
3. redo log是循环写的，固定空间会用完；bin log是可以追加写的。

update流程

1. 执行器通过引擎找到ID=2的这一行
2. 执行器拿到引擎给的行数据，把这个值加1，得到新的一行数据，调用引擎的接口写入这行数据。
3. 引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log中。此时redo log处于prepare状态，然后告知执行器执行完成了，随时可以提交事务。
4. 执行器生成这个操作的binlog，并把binlog写入磁盘。
5. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交状态，更新完成。

![](./image/update流程.png)

两阶段提交保证bin log和redo log的逻辑一致。

bin log记录半个月内的所有逻辑操作。

恢复数据的过程

- 首先找到最近的一次全量备份
- 然后从备份的时间点，依次对这个备份表进行bin log里面的操作。

# 3.事务隔离：为什么你改了我还看不见

事务就是保证一组操作全部成功，或者全部失败。

事务是在引擎层实现的，MyISAM不支持事务，InnoDB不支持事务。

隔离性：ACID，原子性、一致性、隔离性、持久性。

出现的问题：脏读、不可重复读、幻读、

隔离级别：读未提交、读已提交、可重复读、串行化

读未提交：一个事务还没提交时，它做的变更能被其他事务看到。

读提交：一个事务提交之后，它做的变更才能被其他事务看到。

可重复读：一个事务执行过程中的数据，跟这个事务启动时看到的数据一致。

串行化：对于同一行记录，写会加写锁，读会加读锁，当读写锁冲突的时候，后访问的事务必须等前一个访问的事务执行完，才能继续执行。

next-key：行锁+记录所，也可以解决幻读。

设置启动参数：transaction-isolation的值来设置隔离级别。

事务的每条语句都会记录一个回滚操作

# 4.索引（上）

哈希表、有序数组、索引树

InnoDB：B+树，主键索引也叫聚簇索引，叶子节点存储的是真正的数据，非主键索引，也叫二级索引，叶子节点存储的是主键的值。

插入：假设一个结点的关键字数目为M

1. 如果被插入关键字所在的结点含有的关键字小于M，直接插入。
2. 如果被插入关键字所在的结点等于M，则分裂成两个M/2的结点，并位于M/2的关键字当作插入关键字插入到双亲结点。

删除：假设一个结点的最大关键字数目为M

1. 如果不是结点最大或者小的关键字并且关键字个数大于M/2，直接删除。
2. 如果是最大或者最小的关键字，就会涉及到更改其双亲结点一直到根节点。
3. 如果删除导致小于M/2，则向附近的兄弟结点借关键字，同时修改双亲的索引值。
4. 如果兄弟结点没有多余的关键字，则合并。合并时，需要向上更改其双亲的结点。

# 5.索引（下）

联合索引，联合索引的键的数量不是1个，而是两个或者多个，比如键的形式向（2，4）

匹配原则：最左前缀匹配原则，结构可以是最左边的N个字段，或者最左边的M个字符。

# 6. 全局锁和表锁：给表加个字段怎么有那么多阻碍

MySQL的锁有全局锁、表级锁和行锁三个锁。

全局锁，Flush tables with read lock。是给整个数据库实例加锁。使用场景是把整库每个表做备份，注意在备份过程中，整个库都完全处于只读状态。

表级锁：表锁、元数据锁

表锁一般是在数据引擎不支持行锁的时候才会用到。

元数据锁会直到事务提交才释放，在做表结构变更的时候，一定要小心不到导致锁住线上查询和更新。

# 7.行锁功过：怎么减少行锁对性能的影响

行锁是对数据表中的记录行上锁。

解决死锁的策略：直接进入等待，超时释放资源；发起死锁检测，主动回滚死锁链条中的一个事务。将innodb_deadlock_detect设置为on，开启这个逻辑。



